use schemars::{generate::SchemaSettings, JsonSchema, SchemaGenerator};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use snafu::{ResultExt, Snafu};

/// Tool that can be used by the model
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum Tool {
    /// Function-based tool
    Function {
        /// The function declaration for the tool
        function_declarations: Vec<FunctionDeclaration>,
    },
    /// Google Search tool
    GoogleSearch {
        /// The Google Search configuration
        google_search: GoogleSearchConfig,
    },
    URLContext {
        url_context: URLContextConfig,
    },
    /// Google Maps grounding tool
    GoogleMaps {
        /// The Google Maps configuration
        google_maps: GoogleMapsConfig,
    },
    /// Code Execution tool
    CodeExecution {
        #[serde(rename = "codeExecution")]
        code_execution: CodeExecutionConfig,
    },
    /// File Search tool for RAG
    FileSearch {
        /// The File Search configuration
        file_search: FileSearchConfig,
    },
}

/// Empty configuration for Google Search tool
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct GoogleSearchConfig {}

/// Empty configuration for URL Context tool
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct URLContextConfig {}

/// Configuration for Google Maps grounding tool
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct GoogleMapsConfig {
    /// Optional: Enable widget context token generation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enable_widget: Option<bool>,
}

/// Configuration for Code Execution tool. Currently accepts no configuration parameters.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct CodeExecutionConfig {}

/// Code generated by the model for execution.
///
/// Contains executable code that can be run to compute results as part of the generation process.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct ExecutableCode {
    /// Programming language of the code.
    pub language: CodeLanguage,
    /// The source code to execute.
    pub code: String,
}

/// Programming language for code execution
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum CodeLanguage {
    /// Python programming language
    Python,
}

/// Result of code execution.
///
/// Contains the outcome and output of executed code.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct CodeExecutionResult {
    /// Whether the execution succeeded or failed.
    pub outcome: CodeExecutionOutcome,
    /// The output produced by the code execution (stdout/stderr).
    pub output: String,
}

/// Outcome of code execution
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum CodeExecutionOutcome {
    /// Code executed successfully
    OutcomeOk,
    /// Code execution failed (e.g., runtime error, exception)
    OutcomeFailed,
    /// Code execution exceeded time limit
    OutcomeDeadlineExceeded,
}

/// Configuration for File Search tool
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FileSearchConfig {
    /// File search store names to search
    pub file_search_store_names: Vec<String>,

    /// Optional metadata filter (AIP-160 syntax)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata_filter: Option<String>,
}

impl Tool {
    /// Create a new tool with a single function declaration
    pub fn new(function_declaration: FunctionDeclaration) -> Self {
        Self::Function {
            function_declarations: vec![function_declaration],
        }
    }

    /// Create a new tool with multiple function declarations
    pub fn with_functions(function_declarations: Vec<FunctionDeclaration>) -> Self {
        Self::Function {
            function_declarations,
        }
    }

    /// Create a new Google Search tool
    pub fn google_search() -> Self {
        Self::GoogleSearch {
            google_search: GoogleSearchConfig {},
        }
    }

    /// Create a new URL Context tool
    pub fn url_context() -> Self {
        Self::URLContext {
            url_context: URLContextConfig {},
        }
    }

    /// Create a new Google Maps grounding tool
    pub fn google_maps(enable_widget: Option<bool>) -> Self {
        Self::GoogleMaps {
            google_maps: GoogleMapsConfig { enable_widget },
        }
    }

    /// Create a new Code Execution tool
    ///
    /// Enables the model to generate and execute Python code as part of the generation process.
    /// Useful for mathematical calculations, data analysis, and other computational tasks.
    pub fn code_execution() -> Self {
        Self::CodeExecution {
            code_execution: CodeExecutionConfig {},
        }
    }

    /// Create a new File Search tool
    pub fn file_search(store_names: Vec<String>, metadata_filter: Option<String>) -> Self {
        Self::FileSearch {
            file_search: FileSearchConfig {
                file_search_store_names: store_names,
                metadata_filter,
            },
        }
    }
}

/// Defines the function behavior
#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum Behavior {
    /// `default` If set, the system will wait to receive the function response before
    /// continuing the conversation.
    #[default]
    Blocking,
    /// If set, the system will not wait to receive the function response. Instead, it will
    /// attempt to handle function responses as they become available while maintaining the
    /// conversation between the user and the model.
    NonBlocking,
}

/// Declaration of a function that can be called by the model
#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq)]
pub struct FunctionDeclaration {
    /// The name of the function
    pub name: String,
    /// The description of the function
    pub description: String,
    /// `Optional` Specifies the function Behavior. Currently only supported by the BidiGenerateContent method.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behavior: Option<Behavior>,
    /// `Optional` The parameters for the function
    #[serde(skip_serializing_if = "Option::is_none")]
    pub(crate) parameters: Option<Value>,
    /// `Optional` The parameters for the function in JSON Schema format.
    #[serde(
        rename = "parametersJsonSchema",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) parameters_json_schema: Option<Value>,
    /// `Optional` Describes the output from this function in JSON Schema format. Reflects the
    /// Open API 3.03 Response Object. The Schema defines the type used for the response value
    /// of the function.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub(crate) response: Option<Value>,
    /// `Optional` Describes the output from this function in JSON Schema format.
    #[serde(rename = "responseJsonSchema", skip_serializing_if = "Option::is_none")]
    pub(crate) response_json_schema: Option<Value>,
}

/// Returns JSON Schema for the given parameters
fn generate_parameters_schema<Parameters>() -> Value
where
    Parameters: JsonSchema + Serialize,
{
    // Create SchemaSettings with Gemini-optimized settings, see: https://ai.google.dev/api/caching#Schema
    let schema_generator = SchemaGenerator::new(SchemaSettings::openapi3().with(|s| {
        s.inline_subschemas = true;
        s.meta_schema = None;
    }));

    let schema = schema_generator.into_root_schema_for::<Parameters>();
    let mut value = serde_json::to_value(&schema).expect("schema should serialize to JSON value");
    if let Value::Object(map) = &mut value {
        map.remove("title");
        map.remove("components");
    }
    value
}

/// Returns JSON Schema for the given parameters (JSON Schema field for Gemini).
fn generate_parameters_json_schema<Parameters>() -> Value
where
    Parameters: JsonSchema + Serialize,
{
    let schema_generator = SchemaGenerator::new(SchemaSettings::draft07().with(|s| {
        s.inline_subschemas = true;
        s.meta_schema = None;
    }));

    let schema = schema_generator.into_root_schema_for::<Parameters>();
    let mut value = serde_json::to_value(&schema).expect("schema should serialize to JSON value");
    if let Value::Object(map) = &mut value {
        map.remove("title");
        map.remove("$schema");
        map.remove("definitions");
        map.remove("$defs");
    }
    value
}

impl FunctionDeclaration {
    /// Create a new function declaration
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        behavior: Option<Behavior>,
    ) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            behavior,
            ..Default::default()
        }
    }

    /// Set the parameters for the function using a struct that implements `JsonSchema`
    pub fn with_parameters<Parameters>(mut self) -> Self
    where
        Parameters: JsonSchema + Serialize,
    {
        self.parameters = Some(generate_parameters_schema::<Parameters>());
        self.parameters_json_schema = None;
        self
    }

    /// Set the parameters for the function using a JSON Schema representation.
    pub fn with_parameters_json_schema<Parameters>(mut self) -> Self
    where
        Parameters: JsonSchema + Serialize,
    {
        self.parameters_json_schema = Some(generate_parameters_json_schema::<Parameters>());
        self.parameters = None;
        self
    }
    /// Sets the parameters for the function using a raw json_serde::Value. Allows interop with RMCP Tool structs.
    pub fn with_parsed_parameters(mut self, parameters: Value) -> Self {
        self.parameters = Some(parameters.clone());
        self
    }

    /// Set the response schema for the function using a struct that implements `JsonSchema`
    pub fn with_response<Response>(mut self) -> Self
    where
        Response: JsonSchema + Serialize,
    {
        self.response = Some(generate_parameters_schema::<Response>());
        self.response_json_schema = None;
        self
    }

    /// Set the response schema for the function using a JSON Schema representation.
    pub fn with_response_json_schema<Response>(mut self) -> Self
    where
        Response: JsonSchema + Serialize,
    {
        self.response_json_schema = Some(generate_parameters_json_schema::<Response>());
        self.response = None;
        self
    }
    ///Sets the response schema for the function using a raw json_serde::Value. Allows interop with RMCP Tool structs.
    pub fn with_parsed_response(mut self, response: Value) -> Self {
        self.response = Some(response.clone());
        self
    }

}

/// A function call made by the model
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct FunctionCall {
    /// The name of the function
    pub name: String,
    /// The arguments for the function
    pub args: serde_json::Value,
    /// The thought signature for the function call (Gemini 2.5 series only)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thought_signature: Option<String>,
}

#[derive(Debug, Snafu)]
pub enum FunctionCallError {
    #[snafu(display("failed to deserialize parameter '{key}'"))]
    Deserialization {
        source: serde_json::Error,
        key: String,
    },

    #[snafu(display("parameter '{key}' is missing in arguments '{args}'"))]
    MissingParameter {
        key: String,
        args: serde_json::Value,
    },

    #[snafu(display("arguments should be an object; actual: {actual}"))]
    ArgumentTypeMismatch { actual: String },
}

impl FunctionCall {
    /// Create a new function call
    pub fn new(name: impl Into<String>, args: serde_json::Value) -> Self {
        Self {
            name: name.into(),
            args,
            thought_signature: None,
        }
    }

    /// Create a new function call with thought signature
    pub fn with_thought_signature(
        name: impl Into<String>,
        args: serde_json::Value,
        thought_signature: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            args,
            thought_signature: Some(thought_signature.into()),
        }
    }

    /// Get a parameter from the arguments
    pub fn get<T: serde::de::DeserializeOwned>(&self, key: &str) -> Result<T, FunctionCallError> {
        match &self.args {
            serde_json::Value::Object(obj) => {
                if let Some(value) = obj.get(key) {
                    serde_json::from_value(value.clone()).with_context(|_| DeserializationSnafu {
                        key: key.to_string(),
                    })
                } else {
                    Err(MissingParameterSnafu {
                        key: key.to_string(),
                        args: self.args.clone(),
                    }
                    .build())
                }
            }
            _ => Err(ArgumentTypeMismatchSnafu {
                actual: self.args.to_string(),
            }
            .build()),
        }
    }
}

/// A response from a function
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct FunctionResponse {
    /// The name of the function
    pub name: String,
    /// The response from the function
    /// This must be a valid JSON object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
}

impl FunctionResponse {
    /// Create a new function response with a JSON value
    pub fn new(name: impl Into<String>, response: serde_json::Value) -> Self {
        Self {
            name: name.into(),
            response: Some(response),
        }
    }

    /// Create a new function response from a serializable type that will be parsed as JSON
    pub fn from_schema<Response>(
        name: impl Into<String>,
        response: Response,
    ) -> Result<Self, serde_json::Error>
    where
        Response: JsonSchema + Serialize,
    {
        let json = serde_json::to_value(&response)?;
        Ok(Self {
            name: name.into(),
            response: Some(json),
        })
    }

    /// Create a new function response with a string that will be parsed as JSON
    pub fn from_str(
        name: impl Into<String>,
        response: impl Into<String>,
    ) -> Result<Self, serde_json::Error> {
        let json = serde_json::from_str(&response.into())?;
        Ok(Self {
            name: name.into(),
            response: Some(json),
        })
    }
}

/// Configuration for tools
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
pub struct ToolConfig {
    /// The function calling config
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_calling_config: Option<FunctionCallingConfig>,
    /// The retrieval config for location-based tools like Google Maps
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retrieval_config: Option<RetrievalConfig>,
}

/// Configuration for function calling
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct FunctionCallingConfig {
    /// The mode for function calling
    pub mode: FunctionCallingMode,
}

/// Mode for function calling
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum FunctionCallingMode {
    /// The model may use function calling
    Auto,
    /// The model must use function calling
    Any,
    /// The model must not use function calling
    None,
}

/// Retrieval configuration for location-based tools
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct RetrievalConfig {
    /// Optional: Latitude and longitude for location context
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lat_lng: Option<LatLng>,
}

/// Geographic coordinates
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LatLng {
    /// Latitude in degrees
    pub latitude: f64,
    /// Longitude in degrees
    pub longitude: f64,
}

impl LatLng {
    /// Create a new LatLng coordinate
    pub fn new(latitude: f64, longitude: f64) -> Self {
        Self {
            latitude,
            longitude,
        }
    }
}
